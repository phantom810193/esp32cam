# backend/reco.py
# -*- coding: utf-8 -*-
"""
Recommendation core:
- load from SQLite mvp.sqlite3
- compute previous-month distribution
- exclude items already bought in current month
- return top 7 items with "view_rate" & "purchase_prob" (百分比)
"""

from __future__ import annotations
import os, sqlite3, math
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from typing import List, Dict, Any, Optional
from pathlib import Path

TZ = timezone(timedelta(hours=8))  # Asia/Taipei
DB_PATH = Path(os.environ.get("DB_PATH") or "backend/data/mvp.sqlite3")

# 商品型錄（與我幫你生成資料一致）
CATALOG = [
    # code, name, category, price
    ("D001","法式千層蛋糕","甜點",220),
    ("D002","焙茶生乳捲","甜點",180),
    ("D003","宇治抹茶馬卡龍","甜點",60),
    ("D004","半熟乳酪塔","甜點",95),
    ("D005","可可生巧克力","甜點",150),
    ("D006","手工奶酪","甜點",70),

    ("E101","抽取式衛生紙(110抽x12包)","日用品",149),
    ("E102","洗碗精1000ml","日用品",89),
    ("E103","洗衣膠囊(36顆)","日用品",199),
    ("E104","廚房紙巾(6捲)","日用品",129),
    ("E105","垃圾袋(中) 50入","日用品",59),
    ("E106","牙刷四入組","日用品",129),

    ("F201","有機牛奶936ml","食物",95),
    ("F202","嚴選雞蛋10入","食物",85),
    ("F203","鮮凍雞胸肉300g","食物",69),
    ("F204","冷凍鮭魚排2片","食物",189),
    ("F205","蘋果(4入)","食物",99),
    ("F206","香蕉(1串)","食物",55),
    ("F207","全麥吐司","食物",45),
    ("F208","優格(無糖)4入","食物",109),

    ("K301","嬰兒濕紙巾(80抽x6包)","幼兒用品",219),
    ("K302","學習褲(L) 36片","幼兒用品",399),
    ("K303","洗澡沐浴乳(兒童)","幼兒用品",179),
    ("K304","兒童電動牙刷","幼兒用品",499),
    ("K305","兒童保溫水壺","幼兒用品",329),

    ("G401","乳清蛋白1kg(香草)","健身",899),
    ("G402","阻力帶三入組","健身",299),
    ("G403","握力器(可調)","健身",259),
    ("G404","瑜珈墊(8mm)","健身",499),
    ("G405","健身手套","健身",349),

    ("H501","維他命C+鋅90錠","保健食品",299),
    ("H502","魚油膠囊120顆","保健食品",599),
    ("H503","益生菌30包","保健食品",899),
    ("H504","膠原蛋白粉300g","保健食品",699),
    ("H505","葉黃素軟膠囊60顆","保健食品",549),
]
CAT_BY_CODE = {c[0]: c for c in CATALOG}
CATALOG_BY_CATEGORY: Dict[str, List[tuple]] = {}
for code, name, cat, price in CATALOG:
    CATALOG_BY_CATEGORY.setdefault(cat, []).append((code, name, price))

@dataclass
class Member:
    member_id: str
    name: str
    mall_member_id: Optional[str]
    persona_hint: Optional[str] = None  # optional, not required

def _first_last_day_of_previous_month(now: datetime) -> tuple[datetime, datetime]:
    y, m = now.year, now.month
    # previous month
    if m == 1:
        y -= 1
        m = 12
    else:
        m -= 1
    first = datetime(y, m, 1, 0, 0, 0, tzinfo=TZ)
    # last day:
    if m == 12:
        nxt = datetime(y+1, 1, 1, tzinfo=TZ)
    else:
        nxt = datetime(y, m+1, 1, tzinfo=TZ)
    last = nxt - timedelta(seconds=1)
    return first, last

def _first_last_day_of_current_month(now: datetime) -> tuple[datetime, datetime]:
    y, m = now.year, now.month
    first = datetime(y, m, 1, 0, 0, 0, tzinfo=TZ)
    if m == 12:
        nxt = datetime(y+1, 1, 1, tzinfo=TZ)
    else:
        nxt = datetime(y, m+1, 1, tzinfo=TZ)
    last = nxt - timedelta(seconds=1)
    return first, last

def load_member(conn: sqlite3.Connection, member_id: str) -> Optional[Member]:
    cur = conn.execute("SELECT member_id, name, mall_member_id FROM members WHERE member_id=? LIMIT 1", (member_id,))
    row = cur.fetchone()
    if not row:
        return None
    return Member(member_id=row[0], name=row[1], mall_member_id=row[2])

def dominant_category(counts_by_cat: Dict[str, int]) -> Optional[str]:
    if not counts_by_cat:
        return None
    return sorted(counts_by_cat.items(), key=lambda x: (-x[1], x[0]))[0][0]

def recommend_for_member(member_id: str, now: Optional[datetime]=None) -> Dict[str, Any]:
    """
    Returns:
      {
        "member": {...},
        "period": {"prev_month_start":..., "prev_month_end":..., "curr_month_start":..., "curr_month_end":...},
        "status": "new" | "unregistered" | "registered",
        "dominant_category": "甜點" | ... | None,
        "top7": [
            {"product_code","product_name","category","price","view_rate","purchase_prob"}
        ]
      }
    """
    now = now or datetime.now(TZ)
    p_start, p_end = _first_last_day_of_previous_month(now)
    c_start, c_end = _first_last_day_of_current_month(now)

    if not DB_PATH.exists():
        raise FileNotFoundError(f"DB not found at {DB_PATH}")

    conn = sqlite3.connect(str(DB_PATH))
    try:
        m = load_member(conn, member_id)
        if not m:
            # 完全未知的訪客（不在 members 表）：視為新顧客
            return {
                "member": {"member_id": member_id, "name": None, "mall_member_id": None},
                "period": {"prev_month_start": p_start.isoformat(), "prev_month_end": p_end.isoformat(),
                           "curr_month_start": c_start.isoformat(), "curr_month_end": c_end.isoformat()},
                "status": "new",
                "dominant_category": None,
                "top7": []
            }

        # 取上個月購買紀錄
        q_prev = """
        SELECT product_code, product_name, category, price
        FROM reco_purchases
        WHERE member_id=? AND purchased_at BETWEEN ? AND ?
        """
        rows_prev = conn.execute(q_prev, (member_id, p_start.isoformat(), p_end.isoformat())).fetchall()

        # 取本月已購買（用來排除）
        q_curr = """
        SELECT DISTINCT product_code FROM reco_purchases
        WHERE member_id=? AND purchased_at BETWEEN ? AND ?
        """
        bought_curr = {r[0] for r in conn.execute(q_curr, (member_id, c_start.isoformat(), c_end.isoformat())).fetchall()}

        if len(rows_prev) == 0:
            # 無上個月紀錄 -> 若整年也無紀錄即新顧客；但會員存在 ⇒ 未註冊 or 註冊?
            q_year = """
            SELECT COUNT(*) FROM reco_purchases
            WHERE member_id=? AND strftime('%Y', purchased_at)=?
            """
            cnt_year = conn.execute(q_year, (member_id, str(now.year))).fetchone()[0]
            status = "unregistered" if (m.mall_member_id is None) else "registered"
            if cnt_year == 0:
                # 完全沒來過
                return {
                    "member": {"member_id": m.member_id, "name": m.name, "mall_member_id": m.mall_member_id},
                    "period": {"prev_month_start": p_start.isoformat(), "prev_month_end": p_end.isoformat(),
                               "curr_month_start": c_start.isoformat(), "curr_month_end": c_end.isoformat()},
                    "status": "new",
                    "dominant_category": None,
                    "top7": []
                }
            else:
                # 有年度紀錄但上月沒來；用年度近三個月回退
                q_last90 = """
                SELECT product_code, product_name, category, price
                FROM reco_purchases
                WHERE member_id=? AND purchased_at >= ?
                """
                last90_start = (now - timedelta(days=90)).isoformat()
                rows_prev = conn.execute(q_last90, (member_id, last90_start)).fetchall()

        # 類別統計（上月）
        cat_counts: Dict[str, int] = {}
        prod_counts: Dict[str, int] = {}
        for code, name, cat, price in rows_prev:
            cat_counts[cat] = cat_counts.get(cat, 0) + 1
            prod_counts[code] = prod_counts.get(code, 0) + 1

        total_prev = sum(cat_counts.values())
        dom_cat = dominant_category(cat_counts)

        # 候選清單：來自「出現過的類別」的型錄，但排除「本月已購買」
        candidates: List[tuple] = []
        for cat in cat_counts.keys():
            for code, name, price in CATALOG_BY_CATEGORY.get(cat, []):
                if code in bought_curr:
                    continue
                candidates.append((code, name, cat, price))

        if not candidates:
            # 若剛好全買過，退回 dominant 類別全清單
            if dom_cat:
                candidates = [(code, name, dom_cat, price) for code, name, price in CATALOG_BY_CATEGORY.get(dom_cat, [])]

        # 打分數：score = 0.7*P(category) + 0.3*P(product|category)
        # 其中 P(category)= count_cat / total_prev
        #      P(product|category)= freq_product_last_month_in_cat / max_freq_in_cat
        #      若 product 上月沒出現過，視為 0
        cat_prob = {c: (cat_counts[c] / total_prev) if total_prev else 0.0 for c in cat_counts.keys()}

        max_in_cat: Dict[str, int] = {}
        for code, cnt in prod_counts.items():
            cat = CAT_BY_CODE.get(code, (None, None, None, None))[2]
            if not cat: 
                continue
            max_in_cat[cat] = max(max_in_cat.get(cat, 0), cnt)

        scored = []
        for code, name, cat, price in candidates:
            p_cat = cat_prob.get(cat, 0.0)
            freq = prod_counts.get(code, 0)
            denom = max_in_cat.get(cat, 0) or 1
            p_prod_cat = freq / denom
            score = 0.7 * p_cat + 0.3 * p_prod_cat
            # view_rate：以「類別占比」呈現（上月該類別的查閱/關注度代理）
            view_rate = p_cat * 100.0
            scored.append((score, {
                "product_code": code,
                "product_name": name,
                "category": cat,
                "price": float(price),
                "view_rate": round(view_rate, 2)
            }))

        # 取 Top7 並做百分比正規化
        scored.sort(key=lambda x: x[0], reverse=True)
        top = [x[1] for x in scored[:7]] if scored else []

        total_score = sum([s for s, _ in scored[:7]]) or 1.0
        for i, item in enumerate(top):
            s = scored[i][0]
            item["purchase_prob"] = round(100.0 * s / total_score, 2)

        status = "unregistered" if (m.mall_member_id is None) else "registered"
        return {
            "member": {"member_id": m.member_id, "name": m.name, "mall_member_id": m.mall_member_id},
            "period": {"prev_month_start": p_start.isoformat(), "prev_month_end": p_end.isoformat(),
                       "curr_month_start": c_start.isoformat(), "curr_month_end": c_end.isoformat()},
            "status": status,
            "dominant_category": dom_cat,
            "top7": top
        }
    finally:
        conn.close()
